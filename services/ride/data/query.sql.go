// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package ridedata

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDriver = `-- name: CreateDriver :one
INSERT INTO driver (
    name
) VALUES (
  $1
)
RETURNING id, name, status
`

func (q *Queries) CreateDriver(ctx context.Context, name string) (Driver, error) {
	row := q.db.QueryRow(ctx, createDriver, name)
	var i Driver
	err := row.Scan(&i.ID, &i.Name, &i.Status)
	return i, err
}

const createRide = `-- name: CreateRide :one
INSERT INTO ride (
  id, rider_id
) VALUES (
  $1, $2
)
RETURNING id, rider_id, driver_id, ride_status, requested_at, matching_at, matched_at, accepted_at
`

type CreateRideParams struct {
	ID      pgtype.UUID
	RiderID pgtype.UUID
}

func (q *Queries) CreateRide(ctx context.Context, arg CreateRideParams) (Ride, error) {
	row := q.db.QueryRow(ctx, createRide, arg.ID, arg.RiderID)
	var i Ride
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DriverID,
		&i.RideStatus,
		&i.RequestedAt,
		&i.MatchingAt,
		&i.MatchedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const deleteDriver = `-- name: DeleteDriver :exec
DELETE FROM driver
WHERE id = $1
`

func (q *Queries) DeleteDriver(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteDriver, id)
	return err
}

const deleteRide = `-- name: DeleteRide :exec
DELETE FROM ride
WHERE id = $1
`

func (q *Queries) DeleteRide(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRide, id)
	return err
}

const getDriver = `-- name: GetDriver :one
/* 
* Driver
*/ 

SELECT id, name, status FROM driver
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDriver(ctx context.Context, id pgtype.UUID) (Driver, error) {
	row := q.db.QueryRow(ctx, getDriver, id)
	var i Driver
	err := row.Scan(&i.ID, &i.Name, &i.Status)
	return i, err
}

const getRide = `-- name: GetRide :one
/* 
* Ride
*/ 

SELECT id, rider_id, driver_id, ride_status, requested_at, matching_at, matched_at, accepted_at FROM ride
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRide(ctx context.Context, id pgtype.UUID) (Ride, error) {
	row := q.db.QueryRow(ctx, getRide, id)
	var i Ride
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DriverID,
		&i.RideStatus,
		&i.RequestedAt,
		&i.MatchingAt,
		&i.MatchedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const listDrivers = `-- name: ListDrivers :many
SELECT id, name, status FROM driver
ORDER BY name
`

func (q *Queries) ListDrivers(ctx context.Context) ([]Driver, error) {
	rows, err := q.db.Query(ctx, listDrivers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Driver
	for rows.Next() {
		var i Driver
		if err := rows.Scan(&i.ID, &i.Name, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRides = `-- name: ListRides :many
SELECT id, rider_id, driver_id, ride_status, requested_at, matching_at, matched_at, accepted_at FROM ride
ORDER BY requested_at
`

func (q *Queries) ListRides(ctx context.Context) ([]Ride, error) {
	rows, err := q.db.Query(ctx, listRides)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ride
	for rows.Next() {
		var i Ride
		if err := rows.Scan(
			&i.ID,
			&i.RiderID,
			&i.DriverID,
			&i.RideStatus,
			&i.RequestedAt,
			&i.MatchingAt,
			&i.MatchedAt,
			&i.AcceptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDriverStatus = `-- name: UpdateDriverStatus :exec
UPDATE driver
SET status = $2
WHERE id = $1
`

type UpdateDriverStatusParams struct {
	ID     pgtype.UUID
	Status Driverstatus
}

func (q *Queries) UpdateDriverStatus(ctx context.Context, arg UpdateDriverStatusParams) error {
	_, err := q.db.Exec(ctx, updateDriverStatus, arg.ID, arg.Status)
	return err
}

const updateRideAccepted = `-- name: UpdateRideAccepted :one
UPDATE ride
SET driver_id = $2,
    ride_status = 'accepted',
    accepted_at = NOW()
WHERE id = $1
    AND ride_status = 'matched'
RETURNING id, rider_id, driver_id, ride_status, requested_at, matching_at, matched_at, accepted_at
`

type UpdateRideAcceptedParams struct {
	ID       pgtype.UUID
	DriverID pgtype.UUID
}

func (q *Queries) UpdateRideAccepted(ctx context.Context, arg UpdateRideAcceptedParams) (Ride, error) {
	row := q.db.QueryRow(ctx, updateRideAccepted, arg.ID, arg.DriverID)
	var i Ride
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DriverID,
		&i.RideStatus,
		&i.RequestedAt,
		&i.MatchingAt,
		&i.MatchedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const updateRideMatched = `-- name: UpdateRideMatched :one
UPDATE ride
SET ride_status = 'matched',
    matched_at = NOW()
WHERE id = $1
    AND ride_status = 'matching'
RETURNING id, rider_id, driver_id, ride_status, requested_at, matching_at, matched_at, accepted_at
`

func (q *Queries) UpdateRideMatched(ctx context.Context, id pgtype.UUID) (Ride, error) {
	row := q.db.QueryRow(ctx, updateRideMatched, id)
	var i Ride
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DriverID,
		&i.RideStatus,
		&i.RequestedAt,
		&i.MatchingAt,
		&i.MatchedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const updateRideMatching = `-- name: UpdateRideMatching :one

UPDATE ride
SET ride_status = 'matching',
    matching_at = NOW()
WHERE id = $1
    AND ride_status = 'requested'
RETURNING id, rider_id, driver_id, ride_status, requested_at, matching_at, matched_at, accepted_at
`

// TODO: check if 1) ride exists 2) the correct enum is being inserted
func (q *Queries) UpdateRideMatching(ctx context.Context, id pgtype.UUID) (Ride, error) {
	row := q.db.QueryRow(ctx, updateRideMatching, id)
	var i Ride
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DriverID,
		&i.RideStatus,
		&i.RequestedAt,
		&i.MatchingAt,
		&i.MatchedAt,
		&i.AcceptedAt,
	)
	return i, err
}

const updateRideStatus = `-- name: UpdateRideStatus :one
UPDATE ride
SET ride_status = $2
WHERE id = $1 
    AND $2::ridestatus IN ('completed', 'cancelled', 'failed', 'in_progress')
RETURNING id, rider_id, driver_id, ride_status, requested_at, matching_at, matched_at, accepted_at
`

type UpdateRideStatusParams struct {
	ID         pgtype.UUID
	RideStatus Ridestatus
}

func (q *Queries) UpdateRideStatus(ctx context.Context, arg UpdateRideStatusParams) (Ride, error) {
	row := q.db.QueryRow(ctx, updateRideStatus, arg.ID, arg.RideStatus)
	var i Ride
	err := row.Scan(
		&i.ID,
		&i.RiderID,
		&i.DriverID,
		&i.RideStatus,
		&i.RequestedAt,
		&i.MatchingAt,
		&i.MatchedAt,
		&i.AcceptedAt,
	)
	return i, err
}
